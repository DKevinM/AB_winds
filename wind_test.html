<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AB Wind Particles Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    #map {
      width: 100%;
      height: 100%;
      position: relative;
    }
    canvas.wind-layer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 9999;
    }
  </style>
</head>
<body>
<div id="map"></div>

  
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
  const leafletMap = L.map('map').setView([53.5, -113.5], 6);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 12,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(leafletMap);


  function respawnParticle(p) {
    const b = leafletMap.getBounds();
    p.lat = b.getSouth() + Math.random() * (b.getNorth() - b.getSouth());
    p.lon = b.getWest()  + Math.random() * (b.getEast()  - b.getWest());
  }


  
  // ─────────────────────────────────────────
  // Canvas overlay (Leaflet pane version)
  // ─────────────────────────────────────────
  const windCanvas = L.DomUtil.create("canvas", "wind-layer");
  const windCtx = windCanvas.getContext("2d");
  
  // Put canvas in a pane that sits above tiles
  leafletMap.getPanes().overlayPane.appendChild(windCanvas);
  
  // Make sure it can actually be seen
  windCanvas.style.position = "absolute";
  windCanvas.style.top = "0";
  windCanvas.style.left = "0";
  windCanvas.style.pointerEvents = "none";
  windCanvas.style.zIndex = "9999";
  
  function resizeAndRepositionCanvas() {
    const size = leafletMap.getSize();
    windCanvas.width  = size.x;
    windCanvas.height = size.y;
  
    // Position canvas to match map's top-left in layer coords
    const topLeft = leafletMap.containerPointToLayerPoint([0, 0]);
    L.DomUtil.setPosition(windCanvas, topLeft);
  }
  
  leafletMap.on("resize move zoom zoomstart movestart", resizeAndRepositionCanvas);
  resizeAndRepositionCanvas();
  


  // ─────────────────────────────────────────
  // 2) Wind field JSON + simple interpolation
  // ─────────────────────────────────────────
  let windField = null;   // will hold { meta, lats, lons, u, v }
  let particles = [];

  
  // TODO: adjust this path to wherever your JSON lives
  const WIND_JSON_URL = "data/AB_wind_001.json";

  
  fetch(WIND_JSON_URL)
    .then(r => r.json())
    .then(js => {
      windField = js;
      console.log("Loaded wind field:", js.meta);

      initParticles(400);   // your function
    })
    .catch(err => {
      console.error("Failed to load wind field:", err);
    });

  // Nearest-neighbour interpolation of u/v at a given lat/lon.
  // Fine for testing; we can upgrade to bilinear later.
  function interpolateWind(lat, lon) {
    if (!windField || !windField.meta) return null;
  
    const { lat_min, lat_max, lon_min, lon_max, nlat, nlon } = windField.meta;
  
    let lonQ = lon;
    if (lon_min > 180 && lonQ < 0) lonQ += 360;
  
    if (
      lat < Math.min(lat_min, lat_max) || lat > Math.max(lat_min, lat_max) ||
      lonQ < Math.min(lon_min, lon_max) || lonQ > Math.max(lon_min, lon_max)
    ) return null;
  
    const latAscending = lat_max > lat_min;
  
    const dLat = Math.abs(lat_max - lat_min) / (nlat - 1);
    const dLon = Math.abs(lon_max - lon_min) / (nlon - 1);
  
    const fi = latAscending
      ? (lat - lat_min) / dLat
      : (lat_max - lat) / dLat;
  
    const fj = (lonQ - lon_min) / dLon;
  
    const i0 = Math.floor(fi);
    const j0 = Math.floor(fj);
    const i1 = i0 + 1;
    const j1 = j0 + 1;
  
    if (i0 < 0 || j0 < 0 || i1 >= nlat || j1 >= nlon) return null;
  
    const ti = fi - i0;
    const tj = fj - j0;
  
    const u00 = windField.u[i0][j0];
    const u10 = windField.u[i1][j0];
    const u01 = windField.u[i0][j1];
    const u11 = windField.u[i1][j1];
  
    const v00 = windField.v[i0][j0];
    const v10 = windField.v[i1][j0];
    const v01 = windField.v[i0][j1];
    const v11 = windField.v[i1][j1];
  
    if (
      !isFinite(u00) || !isFinite(u10) ||
      !isFinite(u01) || !isFinite(u11) ||
      !isFinite(v00) || !isFinite(v10) ||
      !isFinite(v01) || !isFinite(v11)
    ) return null;
  
    const u =
      u00 * (1 - ti) * (1 - tj) +
      u10 * ti * (1 - tj) +
      u01 * (1 - ti) * tj +
      u11 * ti * tj;
  
    const v =
      v00 * (1 - ti) * (1 - tj) +
      v10 * ti * (1 - tj) +
      v01 * (1 - ti) * tj +
      v11 * ti * tj;
  
    return { u, v };
  }


  // ─────────────────────────────────────────
  // 3) Your particle functions (slotted here)
  // ─────────────────────────────────────────
  
  function initParticles(n = 400) {
    particles = [];
  
    const m = windField.meta;
  
    for (let i = 0; i < n; i++) {
      const lat = m.lat_min + Math.random() * (m.lat_max - m.lat_min);
      const lon = m.lon_min + Math.random() * (m.lon_max - m.lon_min);
  
      particles.push({
        lat,
        lon,
        age: Math.random() * 100
      });
    }
  }
  


  function evolveParticles(dtSeconds) {
    if (!particles.length || !windField) return;
  
    const bounds = leafletMap.getBounds();
  
    for (const p of particles) {
      const w = interpolateWind(p.lat, p.lon);
  
      // If wind missing → respawn
      if (!w) {
        respawnParticle(p);
        continue;
      }
  
      const EARTH_R = 6371000;
  
      const dlat = (w.v * dtSeconds) / EARTH_R * (180 / Math.PI);
      const dlon = (w.u * dtSeconds) /
        (EARTH_R * Math.cos(p.lat * Math.PI / 180)) *
        (180 / Math.PI);
  
      p.lat += dlat;
      p.lon += dlon;
  
      // If particle leaves map → respawn
      if (!bounds.contains([p.lat, p.lon])) {
        respawnParticle(p);
      }
    }
  }
  
    
  function drawParticles() {
    // Fade previous frame
    windCtx.globalCompositeOperation = "source-over";
    windCtx.fillStyle = "rgba(0, 0, 0, 0.05)";
    windCtx.fillRect(0, 0, windCanvas.width, windCanvas.height);
  
    for (const p of particles) {
      const pt = leafletMap.latLngToContainerPoint([p.lat, p.lon]);
  
      if (
        pt.x < 0 || pt.y < 0 ||
        pt.x > windCanvas.width ||
        pt.y > windCanvas.height
      ) continue;
  
      // Colour by speed
      const w = interpolateWind(p.lat, p.lon);
      if (!w) continue;
  
      const speed = Math.hypot(w.u, w.v);
  
      if (speed < 2)       windCtx.strokeStyle = "#2c7bb6";
      else if (speed < 5)  windCtx.strokeStyle = "#abd9e9";
      else if (speed < 8)  windCtx.strokeStyle = "#ffffbf";
      else if (speed <12)  windCtx.strokeStyle = "#fdae61";
      else                 windCtx.strokeStyle = "#d7191c";
  
      windCtx.lineWidth = 1;
  
      windCtx.beginPath();
      windCtx.moveTo(pt.x, pt.y);
      windCtx.lineTo(pt.x - 18, pt.y - 18);
      windCtx.stroke();
    }
  }

  
  let lastTime = performance.now();
  
  function frame(now) {
    requestAnimationFrame(frame);
  
    if (!windField || !particles.length) return;
  
    const dt = (now - lastTime) / 1000;
    lastTime = now;
  
    const dtClamped = Math.min(dt, 0.05);
  
    evolveParticles(dtClamped * 40);
    drawParticles();
  }
  
  requestAnimationFrame(frame);


</script>
</body>
</html>
