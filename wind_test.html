<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AB Wind Particles Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    #map {
      width: 100%;
      height: 100%;
      position: relative;
    }
    canvas.wind-layer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 9999;
    }
  </style>
</head>
<body>
<div id="map"></div>

  
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
  const leafletMap = L.map('map').setView([53.5, -113.5], 6);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 12,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(leafletMap);

  // ─────────────────────────────────────────
  // Canvas overlay (Leaflet pane version)
  // ─────────────────────────────────────────
  const windCanvas = L.DomUtil.create("canvas", "wind-layer");
  const windCtx = windCanvas.getContext("2d");
  
  // Put canvas in a pane that sits above tiles
  leafletMap.getPanes().overlayPane.appendChild(windCanvas);
  
  // Make sure it can actually be seen
  windCanvas.style.position = "absolute";
  windCanvas.style.top = "0";
  windCanvas.style.left = "0";
  windCanvas.style.pointerEvents = "none";
  windCanvas.style.zIndex = "9999";
  
  function resizeAndRepositionCanvas() {
    const size = leafletMap.getSize();
    windCanvas.width  = size.x;
    windCanvas.height = size.y;
  
    // Position canvas to match map's top-left in layer coords
    const topLeft = leafletMap.containerPointToLayerPoint([0, 0]);
    L.DomUtil.setPosition(windCanvas, topLeft);
  }
  
  leafletMap.on("resize move zoom zoomstart movestart", resizeAndRepositionCanvas);
  resizeAndRepositionCanvas();
  


  // ─────────────────────────────────────────
  // 2) Wind field JSON + simple interpolation
  // ─────────────────────────────────────────
  let windField = null;   // will hold { meta, lats, lons, u, v }
  let particles = [];

  
  // TODO: adjust this path to wherever your JSON lives
  const WIND_JSON_URL = "data/AB_wind_001.json";

  fetch(WIND_JSON_URL)
    .then(r => r.json())
    .then(js => {
      windField = js;
      console.log("Loaded wind field:", js.meta);

      initParticles(150);   // your function
    })
    .catch(err => {
      console.error("Failed to load wind field:", err);
    });

  // Nearest-neighbour interpolation of u/v at a given lat/lon.
  // Fine for testing; we can upgrade to bilinear later.

  function interpolateWind(lat, lon) {
    if (!windField || !windField.meta) return null;
  
    const meta = windField.meta;
    const nlat = meta.nlat;
    const nlon = meta.nlon;
    if (!nlat || !nlon) return null;
  
    // Convert lon to 0..360 if the grid is 0..360
    let lonQ = lon;
    if (meta.lon_min > 180 && lonQ < 0) lonQ += 360;
  
    const latMin = meta.lat_min;
    const latMax = meta.lat_max;
    const lonMin = meta.lon_min;
    const lonMax = meta.lon_max;
  
    // bounds guard
    if (lat < Math.min(latMin, latMax) || lat > Math.max(latMin, latMax)) return null;
    if (lonQ < Math.min(lonMin, lonMax) || lonQ > Math.max(lonMin, lonMax)) return null;
  
    const dLat = (latMax - latMin) / (nlat - 1);
    const dLon = (lonMax - lonMin) / (nlon - 1);
  
    let i = Math.round((lat - latMin) / dLat);
    let j = Math.round((lonQ - lonMin) / dLon);
  
    i = Math.max(0, Math.min(nlat - 1, i));
    j = Math.max(0, Math.min(nlon - 1, j));
  
    const u = windField.u[i]?.[j];
    const v = windField.v[i]?.[j];
  
    if (typeof u !== "number" || typeof v !== "number" || !isFinite(u) || !isFinite(v)) {
      return null;
    }
    return { u, v };
  }


  // ─────────────────────────────────────────
  // 3) Your particle functions (slotted here)
  // ─────────────────────────────────────────

  function initParticles(n = 500) {
    particles = [];
    const bounds = leafletMap.getBounds();

    for (let i = 0; i < n; i++) {
      const lat = bounds.getSouth() + Math.random() * (bounds.getNorth() - bounds.getSouth());
      const lon = bounds.getWest()  + Math.random() * (bounds.getEast()  - bounds.getWest());

      particles.push({
        lat,
        lon,
        age: Math.random() * 100
      });
    }
  }

  function evolveParticles(dtSeconds = 300) {
    if (!particles.length) return;

    const bounds = leafletMap.getBounds();

    for (const p of particles) {
      p.age += 1;
      if (p.age > 200) {
        // respawn
        p.age = 0;
        p.lat = bounds.getSouth() + Math.random() * (bounds.getNorth() - bounds.getSouth());
        p.lon = bounds.getWest()  + Math.random() * (bounds.getEast()  - bounds.getWest());
        continue;
      }

      const w = interpolateWind(p.lat, p.lon);
      if (!w) {
        p.age = 999; // kill / respawn soon
        continue;
      }

      // Crude: speed [m/s] * dt [s] -> displacement [m], then to degrees
      const EARTH_R = 6371000;
      const dlat = (w.v * dtSeconds) / EARTH_R * (180 / Math.PI);
      const dlon = (w.u * dtSeconds) / (EARTH_R * Math.cos(p.lat * Math.PI / 180)) * (180 / Math.PI);

      // Move FORWARD in time (trajectories show where air is going)
      p.lat += dlat;
      p.lon += dlon;

      if (!bounds.contains([p.lat, p.lon])) {
        p.age = 999;
      }
    }
  }

  function drawParticles() {
    // Clear ONCE at the start of the frame
    windCtx.clearRect(0, 0, windCanvas.width, windCanvas.height);
  
    // DEBUG: persistent red square
    windCtx.globalAlpha = 1;
    windCtx.fillStyle = "red";
    windCtx.fillRect(10, 10, 40, 40);
  
    // Draw particles
    windCtx.globalAlpha = 0.6;
    windCtx.strokeStyle = "#00ffff";
    windCtx.lineWidth = 1;
      
    for (const p of particles) {
      const latlng = L.latLng(p.lat, p.lon);
      const pt = leafletMap.latLngToContainerPoint(latlng);

      windCtx.beginPath();
      // short streak – you can lengthen this later
      windCtx.moveTo(pt.x, pt.y);
      windCtx.lineTo(pt.x - 2, pt.y - 2);
      windCtx.stroke();
    }
  }

  function frame() {
    requestAnimationFrame(frame);
    if (!windField || !particles.length) return;
    evolveParticles(300);  // 60 seconds per frame (visual scale)
    drawParticles();
  }
  frame();

  // Re-seed particles when you drag/zoom a lot
  leafletMap.on('moveend zoomend', () => {
    if (windField) {
      initParticles(150);
    }
  });
</script>
</body>
</html>
