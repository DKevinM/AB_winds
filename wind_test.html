<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AB Wind Particles Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    #map {
      width: 100%;
      height: 100%;
      position: relative;
    }
    canvas.wind-layer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 9999;
    }
  </style>
</head>
<body>
<div id="map"></div>

  
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
  const leafletMap = L.map('map').setView([53.5, -113.5], 6);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 12,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(leafletMap);


  function respawnParticle(p) {
    const b = leafletMap.getBounds();
    p.lat = b.getSouth() + Math.random() * (b.getNorth() - b.getSouth());
    p.lon = b.getWest()  + Math.random() * (b.getEast()  - b.getWest());
  }


  
  // ─────────────────────────────────────────
  // Canvas overlay (Leaflet pane version)
  // ─────────────────────────────────────────
  const windCanvas = L.DomUtil.create("canvas", "wind-layer");
  const windCtx = windCanvas.getContext("2d");
  
  // Put canvas in a pane that sits above tiles
  leafletMap.getPanes().overlayPane.appendChild(windCanvas);
  
  // Make sure it can actually be seen
  windCanvas.style.position = "absolute";
  windCanvas.style.top = "0";
  windCanvas.style.left = "0";
  windCanvas.style.pointerEvents = "none";
  windCanvas.style.zIndex = "9999";
  
  function resizeAndRepositionCanvas() {
    const size = leafletMap.getSize();
    windCanvas.width  = size.x;
    windCanvas.height = size.y;
  
    // Position canvas to match map's top-left in layer coords
    const topLeft = leafletMap.containerPointToLayerPoint([0, 0]);
    L.DomUtil.setPosition(windCanvas, topLeft);
  }
  
  leafletMap.on("resize move zoom zoomstart movestart", resizeAndRepositionCanvas);
  resizeAndRepositionCanvas();
  


  // ─────────────────────────────────────────
  // 2) Wind field JSON + simple interpolation
  // ─────────────────────────────────────────
  let windField = null;   // will hold { meta, lats, lons, u, v }
  let particles = [];

  
  // TODO: adjust this path to wherever your JSON lives
  const WIND_JSON_URL = "data/AB_wind_001.json";

  
  fetch(WIND_JSON_URL)
    .then(r => r.json())
    .then(js => {
      windField = js;
      console.log("Loaded wind field:", js.meta);

      initParticles(150);   // your function
    })
    .catch(err => {
      console.error("Failed to load wind field:", err);
    });

  // Nearest-neighbour interpolation of u/v at a given lat/lon.
  // Fine for testing; we can upgrade to bilinear later.

  function interpolateWind(lat, lon) {
    if (!windField || !windField.meta) return null;
  
    const meta = windField.meta;
    const nlat = meta.nlat;
    const nlon = meta.nlon;
    if (!nlat || !nlon) return null;
  
    // Convert lon to 0..360 if the grid is 0..360
    let lonQ = lon;
    if (meta.lon_min > 180 && lonQ < 0) lonQ += 360;
  
    const latMin = meta.lat_min;
    const latMax = meta.lat_max;
    const lonMin = meta.lon_min;
    const lonMax = meta.lon_max;
  
    // bounds guard
    if (lat < Math.min(latMin, latMax) || lat > Math.max(latMin, latMax)) return null;
    if (lonQ < Math.min(lonMin, lonMax) || lonQ > Math.max(lonMin, lonMax)) return null;
  
    const dLat = (latMax - latMin) / (nlat - 1);
    const dLon = (lonMax - lonMin) / (nlon - 1);
  
    let i = Math.round((lat - latMin) / dLat);
    let j = Math.round((lonQ - lonMin) / dLon);
  
    i = Math.max(0, Math.min(nlat - 1, i));
    j = Math.max(0, Math.min(nlon - 1, j));
  
    const u = windField.u[i]?.[j];
    const v = windField.v[i]?.[j];
  
    if (typeof u !== "number" || typeof v !== "number" || !isFinite(u) || !isFinite(v)) {
      return null;
    }
    return { u, v };
  }


  // ─────────────────────────────────────────
  // 3) Your particle functions (slotted here)
  // ─────────────────────────────────────────
  
  function initParticles(n = 200) {
    particles = [];
  
    const m = windField.meta;
  
    for (let i = 0; i < n; i++) {
      const lat = m.lat_min + Math.random() * (m.lat_max - m.lat_min);
      const lon = m.lon_min + Math.random() * (m.lon_max - m.lon_min);
  
      particles.push({
        lat,
        lon,
        age: Math.random() * 100
      });
    }
  }
  


  function evolveParticles(dtSeconds) {
    if (!particles.length || !windField) return;
  
    const bounds = leafletMap.getBounds();
  
    for (const p of particles) {
      const w = interpolateWind(p.lat, p.lon);
  
      // If wind missing → respawn
      if (!w) {
        respawnParticle(p);
        continue;
      }
  
      const EARTH_R = 6371000;
  
      const dlat = (w.v * dtSeconds) / EARTH_R * (180 / Math.PI);
      const dlon = (w.u * dtSeconds) /
        (EARTH_R * Math.cos(p.lat * Math.PI / 180)) *
        (180 / Math.PI);
  
      p.lat += dlat;
      p.lon += dlon;
  
      // If particle leaves map → respawn
      if (!bounds.contains([p.lat, p.lon])) {
        respawnParticle(p);
      }
    }
  }
  
  
  function drawParticles() {
    // Fade previous frame (DO NOT clear)
    windCtx.globalCompositeOperation = "source-over";
    windCtx.fillStyle = "rgba(0, 0, 0, 0.05)";
    windCtx.fillRect(0, 0, windCanvas.width, windCanvas.height);
  
    windCtx.strokeStyle = "lime";
    windCtx.lineWidth = 1;
  
    for (const p of particles) {
      const pt = leafletMap.latLngToContainerPoint([p.lat, p.lon]);
  
      if (
        pt.x < 0 || pt.y < 0 ||
        pt.x > windCanvas.width ||
        pt.y > windCanvas.height
      ) continue;
  
      windCtx.beginPath();
      windCtx.moveTo(pt.x, pt.y);
      windCtx.lineTo(pt.x - 12, pt.y - 12);
      windCtx.stroke();
    }
  }

  
  let lastTime = performance.now();
  
  function frame(now) {
    requestAnimationFrame(frame);
  
    if (!windField || !particles.length) return;
  
    const dt = (now - lastTime) / 1000; // seconds since last frame
    lastTime = now;
  
    // Cap dt to avoid jumps
    const dtClamped = Math.min(dt, 0.05);
  
    evolveParticles(dtClamped * 1200); // visual speed factor
    drawParticles();
  }
  
  requestAnimationFrame(frame);

</script>
</body>
</html>
