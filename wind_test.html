<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AB Wind Particles Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    #map {
      width: 100%;
      height: 100%;
      position: relative;
    }
    canvas.wind-layer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 9999;
    }
  </style>
</head>
<body>
<div id="map"></div>

  
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
  const leafletMap = L.map('map').setView([53.5, -113.5], 6);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 12,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(leafletMap);


  function respawnParticle(p) {
    const b = leafletMap.getBounds();
    p.lat = b.getSouth() + Math.random() * (b.getNorth() - b.getSouth());
    p.lon = b.getWest()  + Math.random() * (b.getEast()  - b.getWest());
  }


  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Canvas overlay (Leaflet pane version)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const windCanvas = L.DomUtil.create("canvas", "wind-layer");
  const windCtx = windCanvas.getContext("2d");
  
  // Put canvas in a pane that sits above tiles
  leafletMap.getPanes().overlayPane.appendChild(windCanvas);
  
  // Make sure it can actually be seen
  windCanvas.style.position = "absolute";
  windCanvas.style.top = "0";
  windCanvas.style.left = "0";
  windCanvas.style.pointerEvents = "none";
  windCanvas.style.zIndex = "9999";
  
  function resizeAndRepositionCanvas() {
    const size = leafletMap.getSize();
    windCanvas.width  = size.x;
    windCanvas.height = size.y;
  
    // Position canvas to match map's top-left in layer coords
    const topLeft = leafletMap.containerPointToLayerPoint([0, 0]);
    L.DomUtil.setPosition(windCanvas, topLeft);
  }
  
  leafletMap.on("resize move zoom zoomstart movestart", resizeAndRepositionCanvas);
  resizeAndRepositionCanvas();
  


  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 2) Wind field JSON + simple interpolation
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
  // TODO: adjust this path to wherever your JSON lives
  const WIND_FILES = [
    "data/AB_wind_000.json",
    "data/AB_wind_001.json",
    "data/AB_wind_002.json",
    "data/AB_wind_003.json"
  ];

  let windFields = [];
  let particles = [];
  let blendTime = 0;
  
  
  Promise.all(
    WIND_FILES.map(f =>
      fetch(f)
        .then(r => {
          if (!r.ok) throw new Error(`Failed to load ${f}`);
          return r.json();
        })
    )
  )
  .then(jsons => {
    windFields = jsons;
    console.log("Loaded wind fields:", windFields.length);
    initParticles(400);
  })
  .catch(err => {
    console.error("Wind field load error:", err);
  });
  


  function interpolateWindBlended(lat, lon, t) {
    if (!windFields.length) return null;
  
    // Which two wind snapshots are we between?
    const n = windFields.length;
    const totalSpan = n - 1;
  
    const pos = (t % totalSpan);
    const k0 = Math.floor(pos);
    const k1 = Math.min(k0 + 1, totalSpan);
    const alpha = pos - k0;
  
    const w0 = windFields[k0];
    const w1 = windFields[k1];
  
    const meta = w0.meta;
    const { lat_min, lat_max, lon_min, lon_max, nlat, nlon } = meta;
  
    // Handle 0..360 lon grids
    let lonQ = lon;
    if (lon_min > 180 && lonQ < 0) lonQ += 360;
  
    if (
      lat < Math.min(lat_min, lat_max) ||
      lat > Math.max(lat_min, lat_max) ||
      lonQ < Math.min(lon_min, lon_max) ||
      lonQ > Math.max(lon_min, lon_max)
    ) return null;
  
    const dLat = (lat_max - lat_min) / (nlat - 1);
    const dLon = (lon_max - lon_min) / (nlon - 1);
  
    const fi = (lat - lat_min) / dLat;
    const fj = (lonQ - lon_min) / dLon;
  
    const i0 = Math.floor(fi);
    const j0 = Math.floor(fj);
    const i1 = i0 + 1;
    const j1 = j0 + 1;
  
    if (i0 < 0 || j0 < 0 || i1 >= nlat || j1 >= nlon) return null;
  
    const ti = fi - i0;
    const tj = fj - j0;
  
    function bilinear(arr) {
      const v00 = arr[i0][j0];
      const v10 = arr[i1][j0];
      const v01 = arr[i0][j1];
      const v11 = arr[i1][j1];
  
      if (
        !isFinite(v00) || !isFinite(v10) ||
        !isFinite(v01) || !isFinite(v11)
      ) return null;
  
      return (
        v00 * (1 - ti) * (1 - tj) +
        v10 * ti * (1 - tj) +
        v01 * (1 - ti) * tj +
        v11 * ti * tj
      );
    }
  
    const u0 = bilinear(w0.u);
    const v0 = bilinear(w0.v);
    const u1 = bilinear(w1.u);
    const v1 = bilinear(w1.v);
  
    if (
      u0 === null || v0 === null ||
      u1 === null || v1 === null
    ) return null;
  
    // ðŸ”¥ TIME BLEND
    const u = u0 * (1 - alpha) + u1 * alpha;
    const v = v0 * (1 - alpha) + v1 * alpha;
  
    return { u, v };
  }


  


  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 3) Your particle functions (slotted here)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  function initParticles(n = 400) {
    particles = [];
  
    const m = windField.meta;
  
    for (let i = 0; i < n; i++) {
      const lat = m.lat_min + Math.random() * (m.lat_max - m.lat_min);
      const lon = m.lon_min + Math.random() * (m.lon_max - m.lon_min);
  
      particles.push({
        lat,
        lon,
        age: Math.random() * 100
      });
    }
  }
  


  function evolveParticles(dtSeconds) {
    if (!particles.length || !windField) return;
  
    const bounds = leafletMap.getBounds();
  
    for (const p of particles) {
      const w = interpolateWindBlended(p.lat, p.lon, blendTime);

  
      // If wind missing â†’ respawn
      if (!w) {
        respawnParticle(p);
        continue;
      }
  
      const EARTH_R = 6371000;
  
      const dlat = (w.v * dtSeconds) / EARTH_R * (180 / Math.PI);
      const dlon = (w.u * dtSeconds) /
        (EARTH_R * Math.cos(p.lat * Math.PI / 180)) *
        (180 / Math.PI);
  
      p.lat += dlat;
      p.lon += dlon;
  
      // If particle leaves map â†’ respawn
      if (!bounds.contains([p.lat, p.lon])) {
        respawnParticle(p);
      }
    }
  }
  
    
  function drawParticles() {
    // Fade previous frame
    windCtx.globalCompositeOperation = "source-over";
    windCtx.fillStyle = "rgba(0, 0, 0, 0.05)";
    windCtx.fillRect(0, 0, windCanvas.width, windCanvas.height);
  
    for (const p of particles) {
      const pt = leafletMap.latLngToContainerPoint([p.lat, p.lon]);
  
      if (
        pt.x < 0 || pt.y < 0 ||
        pt.x > windCanvas.width ||
        pt.y > windCanvas.height
      ) continue;
  
      // Colour by speed
      const w = interpolateWind(p.lat, p.lon);
      if (!w) continue;
  
      const speed = Math.hypot(w.u, w.v);
  
      if (speed < 2)       windCtx.strokeStyle = "#2c7bb6";
      else if (speed < 5)  windCtx.strokeStyle = "#abd9e9";
      else if (speed < 8)  windCtx.strokeStyle = "#ffffbf";
      else if (speed <12)  windCtx.strokeStyle = "#fdae61";
      else                 windCtx.strokeStyle = "#d7191c";
  
      windCtx.lineWidth = 1;
  
      windCtx.beginPath();
      windCtx.moveTo(pt.x, pt.y);
      windCtx.lineTo(pt.x - 18, pt.y - 18);
      windCtx.stroke();
    }
  }

  
  let lastTime = performance.now();
  
  function frame(now) {
    requestAnimationFrame(frame);
  
    if (!windField || !particles.length) return;
  
    const dt = (now - lastTime) / 1000;
    lastTime = now;
  
    const dtClamped = Math.min(dt, 0.05);

    blendTime += dtClamped * 0.2;   // controls curvature & evolution
    
    evolveParticles(dtClamped * 40);
    drawParticles();
  }
  
  requestAnimationFrame(frame);


</script>
</body>
</html>
