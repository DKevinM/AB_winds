<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Odour Index — Back Trajectory Tool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="odour/data.js"></script>

  <style>
    body { margin: 0; font-family: Arial; background: #111; color: #eee; }
    #map { height: 80vh; }
    #panel {
      padding: 10px;
      background: #1b1b1b;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    input, button {
      padding: 6px;
      font-size: 14px;
    }
    button { cursor: pointer; }
  </style>
</head>


<body>

<div id="panel">
  <b>Odour Index</b>
  Time (UTC):
  <input id="time" type="datetime-local">
  Hours:
  <input id="hours" type="number" value="4" min="1" max="12">
  <button onclick="runModel()">Run Odour Model</button>
  <span id="status"></span>
</div>

<div id="map"></div>
  



  
<script>
let lastModifiedSeen = null;

let selectedPoint = null;
let centerlineLayer = null;
let cloudLayer = null;

const markerGroup = L.layerGroup();
const paLayer     = L.layerGroup();
const npriLayerGroup = L.layerGroup();
const NPRI_URL = "https://raw.githubusercontent.com/DKevinM/NextGen_dk/main/data/NPRI.geojson";
const map = L.map('map').setView([53.54, -113.49], 7);
const layerRegistry = {};


layerRegistry["Stations"]          = markerGroup;
layerRegistry["Sensors (PurpleAir)"] = paLayer;  

  // ---------------------------------------------
  // AQHI colour function (for categories 1..10+)
  // ---------------------------------------------
  function getColor(aqhi) {
    const lut = {
      "1":  "#01cbff",
      "2":  "#0099cb",
      "3":  "#016797",
      "4":  "#fffe03",
      "5":  "#ffcb00",
      "6":  "#ff9835",
      "7":  "#fd6866",
      "8":  "#fe0002",
      "9":  "#cc0001",
      "10": "#9a0100",
      "10+": "#640100"
    };
    return lut[String(aqhi)] || "#D3D3D3";
  }

  
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 18
}).addTo(map);

const overlayControl = L.control.layers(null, {
  "Stations": markerGroup,
  "PurpleAir": paLayer,
  "NPRI Facilities": npriLayerGroup
}, { collapsed: false }).addTo(map);

fetch(NPRI_URL)
  .then(res => res.json())
  .then(fc => {
    window.NPRI_FC = fc;
    plotNPRI(fc);
    npriLayerGroup.addTo(map);   // default on
  })
  .catch(err => console.error("NPRI load failed:", err));
  
function getFeatureLatLon(src) {
  const g = src.geometry || {};

  if (g.type === "Point") {
    return { lat: g.coordinates[1], lon: g.coordinates[0] };
  }

  const p = src.properties || {};
  const lat = Number(p.lat ?? p.Latitude ?? p.latitude);
  const lon = Number(p.lon ?? p.Longitude ?? p.longitude);

  if (isFinite(lat) && isFinite(lon)) return { lat, lon };
  return null;
}


// PurpleAir eAQHI layer
const PURPLE_URL = "https://raw.githubusercontent.com/DKevinM/AB_datapull/main/data/AB_PM25_map.json";

// eAQHI = floor(pm_corr / 10) + 1, capped to 0–10
function computeEAQHI(pm) {
  if (pm == null || isNaN(pm)) return null;
  let val = Math.floor(pm / 10) + 1;
  if (val < 0) val = 0;
  if (val > 10) val = 10;
  return val;
}

fetch(PURPLE_URL)
  .then(res => res.json())
  .then(data => {
    // handle either array or { data: [...] }
    const records = Array.isArray(data)
      ? data
      : (Array.isArray(data.data) ? data.data : []);

    records.forEach(rec => {
      const lat = parseFloat(rec.lat ?? rec.Latitude ?? rec.latitude);
      const lon = parseFloat(rec.lon ?? rec.Longitude ?? rec.longitude);
      const pm  = parseFloat(rec.pm_corr);

      if (!isFinite(lat) || !isFinite(lon) || !isFinite(pm)) return;

      const eAQHI = computeEAQHI(pm);
      if (eAQHI === null) return;

      // pull out sensor index (with a couple of fallbacks just in case)
      const sensorIndex = rec.sensor_index;
      
      const label = rec.name || (sensorIndex != null
        ? `Sensor ${sensorIndex}`
        : "Unnamed sensor");
      const color = getColor(String(eAQHI));

      const days = Number(new URLSearchParams(location.search).get("days")) || 7;
      
      const marker = L.circleMarker([lat, lon], {
        radius: 4,                 // ~50% smaller than stations (7)
        fillColor: color,
        color: "#222",
        weight: 0.5,
        fillOpacity: 0.85
      }).bindPopup(
        `<strong>PurpleAir</strong><br>` +
        `${label}<br>` +
         (sensorIndex != null ? `Sensor index: ${sensorIndex}<br>` : "") +
        `eAQHI: ${eAQHI}<br>` +
        `PM₂.₅ (corr): ${pm.toFixed(1)} µg/m³` +
        `<hr>` +
        `<a href="/AQHI.forecast/history/sensor_compare.html?sensor_index=${sensorIndex}"
           target="_blank">
           View historical PM2.5
        </a>`          
      );

      marker.addTo(paLayer);
    });

    // Turn on PurpleAir by default (optional)
    paLayer.addTo(map);
  })
  .catch(err => {
    console.error("Error loading PurpleAir data:", err);
  });


let aerLayer = null;
const AER_ZOOM_THRESHOLD = 11;
  
map.on("zoomend", async () => {
  const z = map.getZoom();

  if (z >= AER_ZOOM_THRESHOLD && !aerLayer) {
    console.log("Loading AER layer…");

    try {
      const res = await fetch("odour_data/ST102AER.geojson");
      if (!res.ok) throw new Error("AER file missing");

      const geo = await res.json();

      aerLayer = L.geoJSON(geo, {
        style: { color: "#888", weight: 1, opacity: 0.6 }
      }).addTo(map);

      overlayControl.addOverlay(aerLayer, "AER Facilities");

    } catch (e) {
      console.warn("Skipping AER:", e.message);
    }
  }

  if (z < AER_ZOOM_THRESHOLD && aerLayer) {
    map.removeLayer(aerLayer);
    aerLayer = null;
  }
});


  
  
let marker;

map.on('click', e => {
  selectedPoint = e.latlng;
  if (marker) map.removeLayer(marker);
  marker = L.marker(e.latlng).addTo(map);
});

markerGroup.addTo(map);
paLayer.addTo(map);
  

async function checkForNewOutput(startTime) {
  const res = await fetch(`odour_data/backtraj_centerlines.geojson?nocache=${Date.now()}`, { method: "HEAD" });
  if (!res.ok) return false;

  const lm = res.headers.get("Last-Modified");

  if (!lastModifiedSeen) {
    lastModifiedSeen = lm;
    return false;
  }

  if (lm !== lastModifiedSeen && Date.now() - startTime > 60000) {
    lastModifiedSeen = lm;
    return true;
  }

  return false;
}


function plotNPRI(fc) {
  npriLayerGroup.clearLayers();
  if (!fc || !Array.isArray(fc.features)) return;

  fc.features.forEach(f => {
    const ll = getFeatureLatLon(f);
    if (!ll) return;

    const p   = f.properties || {};
    const fac = p.FACILITY_NAME || p.FacilityName || "Facility";
    const co  = p.COMPANY_NAME  || p.Company      || "";
    const yr  = p.REPORTING_YEAR || p.ReportingYear || "";
    const label = co ? `${fac} (${co})` : fac;

    L.circleMarker([ll.lat, ll.lon], {
      radius: 4,
      color: "#cc0000",
      weight: 1,
      fillOpacity: 0.8
    })
      .bindPopup(`
        <b>${label}</b><br>
        ${yr ? "Year: " + yr + "<br>" : ""}
        <small>${ll.lat.toFixed(4)}, ${ll.lon.toFixed(4)}</small>
      `)
      .addTo(npriLayerGroup);
  });

  console.log("[odour] plotted NPRI:", fc.features.length);
}

  window.dataReady.then(() => {
    fetchAllStationData().then(allStations => {
      allStations.forEach(({ stationName, lat, lon, html, aqhi }) => {
        const fillColor = getColor(String(aqhi || "NA"));
  
        const marker = L.circleMarker([lat, lon], {
          radius: 7,
          fillColor: fillColor,
          color: "#222",
          weight: 1,
          fillOpacity: 0.85
        }).bindPopup(html);
  
        marker.addTo(markerGroup);
      });
  });
  
async function loadTrajectories() {
  try {
    const centerRes = await fetch("odour_data/backtraj_centerlines.geojson", { cache: "no-store" });
    const cloudRes  = await fetch("odour_data/backtraj_cloud.geojson", { cache: "no-store" });

    if (!centerRes.ok || !cloudRes.ok) return false;

    const centerGeo = await centerRes.json();
    const cloudGeo  = await cloudRes.json();

    if (centerlineLayer) map.removeLayer(centerlineLayer);
    if (cloudLayer) map.removeLayer(cloudLayer);

    
    const density = {};
    const cellSize = 0.01; // ≈ 1 km grid
    
    function cellKey(lat, lon) {
      const y = Math.round(lat / cellSize) * cellSize;
      const x = Math.round(lon / cellSize) * cellSize;
      return `${y.toFixed(3)},${x.toFixed(3)}`;
    }
    
    cloudGeo.features.forEach(f => {
      const [lon, lat] = f.geometry.coordinates;
      const key = cellKey(lat, lon);
      density[key] = (density[key] || 0) + 1;
    });



    function densityColor(n){
      if (n >= 15) return "#ff0000";   // very high
      if (n >= 10) return "#ff6600";   // high
      if (n >= 5)  return "#ffaa00";   // medium
      if (n >= 2)  return "#ffff00";   // low
      return "#66ccff";                // very low
    }


    
    cloudLayer = L.geoJSON(cloudGeo, {
      pointToLayer: (f, latlng) => {
        const key = cellKey(latlng.lat, latlng.lng);
        const d = density[key] || 1;
    
        return L.circleMarker(latlng, {
          radius: Math.min(10, 2 + d),
          fillColor: densityColor(d),
          color: "#111",
          weight: 0.5,
          fillOpacity: 0.8
        });
      }
    }).addTo(map);





    centerlineLayer = L.geoJSON(centerGeo, {
      style: { color: "#00ffff", weight: 2 }
    }).addTo(map);
    
    overlayControl.addOverlay(centerlineLayer, "Trajectory Trend");
    overlayControl.addOverlay(cloudLayer, "Particle Cloud");

    return true;
  } catch (e) {
    console.warn("Waiting for model output…");
    return false;
  }
}


async function runModel() {
  if (!selectedPoint) {
    alert("Click on the map first.");
    return;
  }

  const time = document.getElementById("time").value;
  const hours = document.getElementById("hours").value;

  if (!time) {
    alert("Enter a UTC time.");
    return;
  }

  document.getElementById("status").innerText = "Triggering model…";

  const res = await fetch("https://lingering-sun-ff8a.drkevmcc.workers.dev", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      lat: selectedPoint.lat,
      lon: selectedPoint.lng,
      time: time,
      hours: hours
    })
  });

  if (!res.ok) {
    document.getElementById("status").innerText = "Error triggering model";
    return;
  }

  document.getElementById("status").innerText = "Model running… waiting for output";

  const startTime = Date.now();

  const poll = setInterval(async () => {
    const ready = await checkForNewOutput(startTime);

    if (ready) {
      clearInterval(poll);
      await loadTrajectories();
      document.getElementById("status").innerText = "Trajectories loaded";
    }
  }, 15000);
}

  
</script>

  
</body>
</html>
