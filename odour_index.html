<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Odour Index — Back Trajectory Tool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    body { margin: 0; font-family: Arial; background: #111; color: #eee; }
    #map { height: 80vh; }
    #panel {
      padding: 10px;
      background: #1b1b1b;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    input, button {
      padding: 6px;
      font-size: 14px;
    }
    button { cursor: pointer; }
  </style>
</head>

<body>

<div id="panel">
  <b>Odour Index</b>
  Time (UTC):
  <input id="time" type="datetime-local">
  Hours:
  <input id="hours" type="number" value="4" min="1" max="12">
  <button onclick="runModel()">Run Odour Model</button>
  <span id="status"></span>
</div>

<div id="map"></div>

<script>
let lastModifiedSeen = null;

let selectedPoint = null;
let centerlineLayer = null;
let cloudLayer = null;

const map = L.map('map').setView([53.54, -113.49], 7);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 18
}).addTo(map);

const overlayControl = L.control.layers(null, {}, { collapsed: false }).addTo(map);

let marker;

map.on('click', e => {
  selectedPoint = e.latlng;
  if (marker) map.removeLayer(marker);
  marker = L.marker(e.latlng).addTo(map);
});


async function checkForNewOutput(startTime) {
  const res = await fetch(`odour_data/backtraj_centerlines.geojson?nocache=${Date.now()}`, { method: "HEAD" });
  if (!res.ok) return false;

  const lm = res.headers.get("Last-Modified");

  if (!lastModifiedSeen) {
    lastModifiedSeen = lm;
    return false;
  }

  if (lm !== lastModifiedSeen && Date.now() - startTime > 60000) {
    lastModifiedSeen = lm;
    return true;
  }

  return false;
}


async function loadTrajectories() {
  try {
    const centerRes = await fetch("odour_data/backtraj_centerlines.geojson", { cache: "no-store" });
    const cloudRes  = await fetch("odour_data/backtraj_cloud.geojson", { cache: "no-store" });

    if (!centerRes.ok || !cloudRes.ok) return false;

    const centerGeo = await centerRes.json();
    const cloudGeo  = await cloudRes.json();

    if (centerlineLayer) map.removeLayer(centerlineLayer);
    if (cloudLayer) map.removeLayer(cloudLayer);

    const density = {};
    cloudGeo.features.forEach(f => {
      const key = f.geometry.coordinates.join(",");
      density[key] = (density[key] || 0) + 1;
    });

    function colorForDensity(n) {
      if (n > 15) return "#ff0000";
      if (n > 8) return "#ff8800";
      if (n > 3) return "#ffff00";
      return "#33ccff";
    }

    centerlineLayer = L.geoJSON(centerGeo, {
      style: { color: "#ff3333", weight: 3 }
    }).addTo(map);

    cloudLayer = L.geoJSON(cloudGeo, {
      pointToLayer: (f, latlng) => {
        const key = f.geometry.coordinates.join(",");
        const d = density[key] || 1;

        return L.circleMarker(latlng, {
          radius: Math.min(8, 2 + d),
          color: colorForDensity(d),
          fillOpacity: 0.7
        });
      }
    }).addTo(map);

    overlayControl.addOverlay(centerlineLayer, "Trajectory Trend");
    overlayControl.addOverlay(cloudLayer, "Particle Cloud");

    return true;
  } catch (e) {
    console.warn("Waiting for model output…");
    return false;
  }
}


async function runModel() {
  if (!selectedPoint) {
    alert("Click on the map first.");
    return;
  }

  const time = document.getElementById("time").value;
  const hours = document.getElementById("hours").value;

  if (!time) {
    alert("Enter a UTC time.");
    return;
  }

  document.getElementById("status").innerText = "Triggering model…";

  const res = await fetch("https://lingering-sun-ff8a.drkevmcc.workers.dev", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      lat: selectedPoint.lat,
      lon: selectedPoint.lng,
      time: time,
      hours: hours
    })
  });

  if (!res.ok) {
    document.getElementById("status").innerText = "Error triggering model";
    return;
  }

  document.getElementById("status").innerText = "Model running… waiting for output";

  const startTime = Date.now();

  const poll = setInterval(async () => {
    const ready = await checkForNewOutput(startTime);

    if (ready) {
      clearInterval(poll);
      await loadTrajectories();
      document.getElementById("status").innerText = "Trajectories loaded";
    }
  }, 15000);
}
</script>

  
</body>
</html>
