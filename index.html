<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AB Wind (Leaflet)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }
    .info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 999;
      background: rgba(0,0,0,0.7);
      color: #fff;
      font: 14px/1.3 Arial, sans-serif;
      padding: 8px 10px;
      border-radius: 6px;
      max-width: 360px;
    }
    canvas.wind {
      position: absolute;
      inset: 0;
      pointer-events: none; /* don’t block map interaction */
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="info" id="info">Loading wind…</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>



  <script>
    let field = null;
    // ---------- CONFIG YOU MAY NEED TO EDIT ----------
    // These MUST match whatever your ab_wind_json.py writes into the header.
    // If your JSON header names differ, adjust readHeader() below.
    const U_URL = "data/AB_u_000.json";
    const V_URL = "data/AB_v_000.json";

    // If your grid is Alberta-only, set a reasonable start view:
    const map = L.map("map", { zoomControl: true }).setView([54.5, -114.0], 6);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 12,
      attribution: "&copy; OpenStreetMap"
    }).addTo(map);

    // ---------- Minimal wind particle canvas layer ----------
    const WindLayer = L.Layer.extend({
      onAdd: function(map) {
        this._map = map;
        this._canvas = L.DomUtil.create("canvas", "wind");
        this._canvas.classList.add("wind");
        this._ctx = this._canvas.getContext("2d");
        map.getPanes().overlayPane.appendChild(this._canvas);

        map.on("move zoom resize", this._reset, this);
        this._reset();
      },
      onRemove: function(map) {
        map.off("move zoom resize", this._reset, this);
        this._canvas.remove();
      },
      setField: function(field) {
        this._field = field;
        this._initParticles();
        this._start();
      },
      _reset: function() {
        const size = this._map.getSize();
        this._canvas.width = size.x;
        this._canvas.height = size.y;
      },
      _initParticles: function() {
        const count = Math.round(this._map.getSize().x * 0.8); // adjust density
        this._particles = Array.from({ length: count }, () => this._randomParticle());
      },
      _randomParticle: function() {
        // pick random screen point until we land inside the grid
        for (let k = 0; k < 30; k++) {
          const x = Math.random() * this._canvas.width;
          const y = Math.random() * this._canvas.height;
          const ll = this._map.containerPointToLatLng([x, y]);
          const v = this._field.sample(ll.lat, ll.lng);
          if (v) return { x, y, age: Math.random() * 80 };
        }
        return { x: Math.random()*this._canvas.width, y: Math.random()*this._canvas.height, age: 0 };
      },
      _start: function() {
        if (this._anim) cancelAnimationFrame(this._anim);
        const frame = () => {
          this._step();
          this._anim = requestAnimationFrame(frame);
        };
        frame();
      },
      _step: function() {
        if (!this._field) return;
        const ctx = this._ctx;

        // fade trails
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = "rgba(0,0,0,0.06)";
        ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);

        ctx.globalCompositeOperation = "lighter";
        ctx.lineWidth = 1;

        for (const p of this._particles) {
          if (p.age++ > 80) {
            Object.assign(p, this._randomParticle());
            continue;
          }

          const ll = this._map.containerPointToLatLng([p.x, p.y]);
          const v = this._field.sample(ll.lat, ll.lng);
          if (!v) {
            Object.assign(p, this._randomParticle());
            continue;
          }

          // v = {u, v, speed}
          const speed = v.speed; // m/s
          const step = Math.min(3.0, speed * 0.35); // tune feel

          // convert wind direction in lat/lng to screen dx/dy approximately:
          // move a tiny amount in lat/lng, project, and compute delta pixels
          const dLat = (v.v / 111320) * 0.08; // rough deg per m (scaled)
          const dLng = (v.u / (111320 * Math.cos(ll.lat * Math.PI/180))) * 0.08;

          const p1 = this._map.latLngToContainerPoint([ll.lat, ll.lng]);
          const p2 = this._map.latLngToContainerPoint([ll.lat + dLat, ll.lng + dLng]);

          const dx = (p2.x - p1.x) * step;
          const dy = (p2.y - p1.y) * step;

          const x2 = p.x + dx;
          const y2 = p.y + dy;

          // color by speed
          const c = Math.min(255, Math.round(speed * 10));
          ctx.strokeStyle = `rgba(${c}, ${255-c}, 255, 0.85)`;

          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(x2, y2);
          ctx.stroke();

          p.x = x2;
          p.y = y2;

          // recycle if offscreen
          if (p.x < 0 || p.y < 0 || p.x > this._canvas.width || p.y > this._canvas.height) {
            Object.assign(p, this._randomParticle());
          }
        }
      }
    });

    // ---------- Parse your JSONs into a sampler ----------
    function readHeader(json) {
      // Try common variants. Adjust once we see your actual header keys.
      const h = json.header || json[0]?.header || json;
      return {
        lo1: h.lo1 ?? h.lon0 ?? h.lo ?? h.lo1,
        la1: h.la1 ?? h.lat0 ?? h.la ?? h.la1,
        dx:  h.dx  ?? h.dlon ?? h.dx,
        dy:  h.dy  ?? h.dlat ?? h.dy,
        nx:  h.nx  ?? h.Nx   ?? h.nx,
        ny:  h.ny  ?? h.Ny   ?? h.ny,
      };
    }

    function buildField(uJson, vJson) {
      console.log("DEBUG: First 50 U values:", uJson.data.slice(0, 50));
      console.log("DEBUG: First 50 V values:", vJson.data.slice(0, 50));
      
      const uh = uJson.header;
      const vh = vJson.header;
      
      // Your actual grid parameters
      const nx = uh.nx;          // 354
      const ny = uh.ny;          // 540
      const lon0 = uh.lo1;       // -121.76788
      const lat0 = uh.la1;       // 60.64398 (NORTHERN point)
      const dx = uh.dx;          // 0.04537
      const dy = uh.dy;          // 0.02274 POSITIVE = goes SOUTHWARD
      
      console.log(`Grid: ${nx}x${ny}, Origin: (${lon0}, ${lat0}), dx:${dx}, dy:${dy}`);
      console.log(`Grid covers: Lon ${lon0} to ${lon0 + dx * (nx-1)}, 
                   Lat ${lat0} to ${lat0 - dy * (ny-1)}`); // Note: minus because dy positive
      
      const uData = uJson.data;
      const vData = vJson.data;
      
      // Find first non-null value
      let firstNonNull = -1;
      for (let i = 0; i < uData.length; i++) {
        if (uData[i] !== null) {
          firstNonNull = i;
          break;
        }
      }
      console.log(`First non-null U at index ${firstNonNull}: ${uData[firstNonNull]}`);
      
      // Test different indices to understand data layout
      console.log("Testing data at various indices:");
      for (let idx of [1000, 5000, 10000, 50000, 100000]) {
        console.log(`  [${idx}]: U=${uData[idx]}, V=${vData[idx]}`);
      }
      
      return {
        nx, ny, lon0, lat0, dx, dy,
        sample: (lat, lon) => {
          // Calculate grid indices
          // lon index: works fine
          const i = Math.floor((lon - lon0) / dx);
          
          // lat index: CRITICAL - your grid goes SOUTHWARD from northern point
          // lat0 = 60.64 (north), dy = +0.0227 (southward)
          // So: lat = lat0 - (j * dy)
          // Therefore: j = (lat0 - lat) / dy
          const j = Math.floor((lat0 - lat) / dy);
          
          // Check bounds
          if (i < 0 || i >= nx || j < 0 || j >= ny) {
            // For debugging: show what's wrong
            if (Math.abs(lat - 54.5) < 0.5 && Math.abs(lon + 114) < 1) {
              console.log(`Out of bounds: lat=${lat}, lon=${lon}, i=${i}, j=${j}, 
                          bounds: i[0-${nx-1}], j[0-${ny-1}]`);
            }
            return null;
          }
          
          // Calculate data index (row-major: j rows down, i columns across)
          const dataIndex = j * nx + i;
          
          // Debug for Alberta center
          if (Math.abs(lat - 54.5) < 0.1 && Math.abs(lon + 114.0) < 0.1) {
            console.log(`Alberta center: lat=${lat}, lon=${lon}, i=${i}, j=${j}, idx=${dataIndex}`);
            console.log(`  U[${dataIndex}]=${uData[dataIndex]}, V[${dataIndex}]=${vData[dataIndex]}`);
          }
          
          const uu = uData[dataIndex];
          const vv = vData[dataIndex];
          
          // Handle null/missing data
          if (uu === null || vv === null || 
              uu === undefined || vv === undefined) {
            return null;
          }
          
          const speed = Math.sqrt(uu * uu + vv * vv);
          
          return {
            u: uu,
            v: vv,
            speed: speed
          };
        }
      };
    }

    async function loadWind() {
      const info = document.getElementById("info");
      info.textContent = "Loading wind JSON…";

      const [uRes, vRes] = await Promise.all([fetch(U_URL), fetch(V_URL)]);
      if (!uRes.ok) throw new Error(`U fetch failed: ${uRes.status}`);
      if (!vRes.ok) throw new Error(`V fetch failed: ${vRes.status}`);

      const [uJson, vJson] = await Promise.all([uRes.json(), vRes.json()]);
      field = buildField(uJson, vJson);

  
      // NEW: Test a grid of points to see coverage
      console.log("=== DATA COVERAGE TEST ===");
      const testLats = [60, 58, 56, 54, 52, 50];  // From north to south
      const testLons = [-125, -120, -115, -110];  // West to east
      
      for (const lat of testLats) {
        for (const lon of testLons) {
          const result = field.sample(lat, lon);
          console.log(`(${lat}, ${lon}): ${result ? `U=${result.u.toFixed(2)}, V=${result.v.toFixed(2)}` : 'NO DATA'}`);
        }
      }
      
        // DEBUG: Log the actual structure
      console.log("U JSON structure:", uJson);
      console.log("V JSON structure:", vJson);
        // Check what keys exist in the header
      if (uJson.header) {
        console.log("U Header keys:", Object.keys(uJson.header));
        console.log("U Header values:", uJson.header);
      }

      // Check data array length
      const uData = uJson.data || uJson[0]?.data;
      const vData = vJson.data || vJson[0]?.data;
      console.log("U data length:", uData?.length);
      console.log("V data length:", vData?.length);

      
      // DEBUG: probe center of Alberta
      const testLat = 54.5;
      const testLon = -114.0;
      const test = field.sample(testLat, testLon);
      console.log("TEST SAMPLE @ AB:", test);




      let testParticle = {
        lat: 54.5,
        lon: -114.0
      };
      
      function stepParticle() {
        const wind = field.sample(testParticle.lat, testParticle.lon);
        if (!wind) {
          console.log("No wind at particle location");
          return;
        }
      
        const dt = 120; // seconds
      
        const metersPerDegLat = 111320;
        const metersPerDegLon = 111320 * Math.cos(testParticle.lat * Math.PI/180);
      
        testParticle.lon += (wind.u * dt) / metersPerDegLon;
        testParticle.lat += (wind.v * dt) / metersPerDegLat;
      
        console.log("Particle moved to:", testParticle.lat.toFixed(5), testParticle.lon.toFixed(5));
      }

      

      
      if (!test) {
        document.getElementById("info").textContent =
          "Wind loaded but grid sample is NULL (indexing issue)";
      }


      info.textContent = "Wind loaded (particles running)";
      return field;
    }

    const windLayer = new WindLayer();
    windLayer.addTo(map);

    loadWind()
      .then(field => windLayer.setField(field))
      .catch(err => {
        document.getElementById("info").textContent = "ERROR: " + err.message;
        console.error(err);
      });

    function runDiagnosticTest() {
      console.log("=== DIAGNOSTIC TEST ===");
      
      // Test 1: Check if files exist
      fetch(U_URL).then(r => {
        console.log(`U file status: ${r.status} ${r.statusText}`);
        return r.json();
      }).then(data => {
        console.log("U data type:", typeof data);
        console.log("U keys:", Object.keys(data));
        
        if (data.header) {
          console.log("Header exists with keys:", Object.keys(data.header));
        }
        
        // Show first few data points
        const dataArray = data.data || data.values || data.u;
        if (dataArray && dataArray.length) {
          console.log("First 5 U values:", dataArray.slice(0, 5));
          console.log("Data length:", dataArray.length);
        }
      }).catch(err => console.error("U fetch error:", err));
      
      // Repeat for V
      fetch(V_URL).then(r => {
        console.log(`V file status: ${r.status} ${r.statusText}`);
        return r.json();
      }).then(data => {
        console.log("V keys:", Object.keys(data));
        const dataArray = data.data || data.values || data.v;
        if (dataArray && dataArray.length) {
          console.log("First 5 V values:", dataArray.slice(0, 5));
        }
      }).catch(err => console.error("V fetch error:", err));
    }
    
    // Run after page loads
    window.addEventListener('load', () => {
      setTimeout(runDiagnosticTest, 1000);
    });
        
  </script>
</body>
</html>
