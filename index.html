<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AB Wind (Leaflet)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }
    .info {
      position: absolute;
      top: 10px;
      left: 60px;
      z-index: 999;
      background: rgba(0,0,0,0.7);
      color: #fff;
      font: 14px/1.3 Arial, sans-serif;
      padding: 8px 10px;
      border-radius: 6px;
      max-width: 360px;
    }
    canvas.wind {
      position: absolute;
      top: 0;
      left: 0;
      transform: none !important;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="info" id="info">Loading windâ€¦</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script type="module">
  import { GITHUB_TOKEN } from "./config.js";
  window.GITHUB_TOKEN = GITHUB_TOKEN;
  </script>

  <script>
    let field = null;
    let windTime = {
      baseUTC: null,
      i: 0,
      a: 0
    };    
    // ---------- CONFIG YOU MAY NEED TO EDIT ----------
    // These MUST match whatever your ab_wind_json.py writes into the header.
    // If your JSON header names differ, adjust readHeader() below.
    const HOURS = [0,1,2,3];
    const U_URLS = HOURS.map(h => `data/AB_u_00${h}.json`);
    const V_URLS = HOURS.map(h => `data/AB_v_00${h}.json`);


    // If your grid is Alberta-only, set a reasonable start view:
    const map = L.map("map", { zoomControl: true }).setView([54.5, -114.0], 6);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 12,
      attribution: "&copy; OpenStreetMap"
    }).addTo(map);


    function getDataAgeText(modelTimeISO) {
      if (!modelTimeISO) return "Data age: unknown";
    
      const modelTime = Date.parse(modelTimeISO);
      const nowUTC = Date.now();
    
      const diffMs = nowUTC - modelTime;
    
      const diffMin = Math.floor(diffMs / 60000);
      const hours = Math.floor(diffMin / 60);
      const minutes = diffMin % 60;
    
      if (hours > 0) {
        return `Data age: ${hours}h ${minutes}m`;
      } else {
        return `Data age: ${minutes}m`;
      }
    }


    function getEffectiveWindTime() {
      if (!windTime.baseUTC) return null;
      return new Date(
        windTime.baseUTC.getTime() + (windTime.i + windTime.a) * 3600_000
      );
    }

    
    function getWindTimeDiagnostics() {
      if (!field || !windTime.baseUTC) return "Wind time: unknown";
    
      const modelUTC = new Date(windTime.baseUTC).toUTCString();
      const effectiveTime = getEffectiveWindTime();
      const nowUTC = new Date();
    
      const ageMs = nowUTC - effectiveTime;
      const ageMin = Math.floor(ageMs / 60000);
      const h = Math.floor(ageMin / 60);
      const m = ageMin % 60;
    
      const ageText = h > 0 ? `${h}h ${m}m` : `${m}m`;
    
      return `
    Model cycle: ${modelUTC}<br>
    Effective wind time: ${effectiveTime.toUTCString()
        }`;
    // Current time: ${nowUTC.toUTCString()}<br>
    // <b>Data age: ${ageText}</b>
    }
    
    
    const overlays = {};   // for layer control

    
    function loadOutlineLayer(url, color, name) {
      return fetch(url)
        .then(r => r.json())
        .then(geo => {
          const layer = L.geoJSON(geo, {
            style: {
              color: color,
              weight: 4,
              opacity: 1,
              fillOpacity: 0,
              dashArray: "6 3"
            }
          });
    
          overlays[name] = layer;
          layer.addTo(map);
        });
    }
    
    // Load ACA and WCAS
    Promise.all([
      loadOutlineLayer("data/ACA.geojson", "#ffcc00", "ACA Airshed"),
      loadOutlineLayer("data/WCAS.geojson", "#00ffff", "WCAS Airshed")
    ]).then(() => {
      L.control.layers(null, overlays, { collapsed: false }).addTo(map);
    });



    

    // ---------- Minimal wind particle canvas layer ----------
    const WindLayer = L.Layer.extend({
      onAdd: function(map) {
        this._map = map;
        this._canvas = L.DomUtil.create("canvas", "wind");
        this._canvas.classList.add("wind");
        this._ctx = this._canvas.getContext("2d");
        this._canvas.width = window.innerWidth;
        this._canvas.height = window.innerHeight;
        
        this._ctx.fillStyle = "rgba(255, 0, 0, 1)";
        this._ctx.fillRect(50, 50, 100, 100);
        
        console.log("CANVAS ADDED", this._canvas);
        
        map.getPanes().overlayPane.appendChild(this._canvas);

        map.on("move zoom resize", this._reset, this);
        map.on("moveend zoomend resize", this._updateMaskPath, this);
        
        this._reset();
      },

      
      _onZoomStart: function() {
        if (!this._ctx) return;
        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
      
        // Optional but recommended: reseed so you don't get "stuck" particles
        if (this._field) this._initParticles();
      },
    
      onRemove: function(map) {
        map.off("move zoom resize", this._reset, this);
        if (this._anim) cancelAnimationFrame(this._anim);
        this._canvas.remove();
      },
    
      setField: function(field) {
        this._field = field;
        this._initParticles();
        this._start();
      },
      
      updateField: function(field) {
        this._field = field;
      },
      



      _reset: function () {
        const size = this._map.getSize();
      
        // This is the missing anchor that fixes everything
        this._topLeft = this._map.containerPointToLayerPoint([0, 0]);
      
        L.DomUtil.setPosition(this._canvas, this._topLeft);
      
        this._canvas.width = size.x;
        this._canvas.height = size.y;
      
        this._ctx.clearRect(0, 0, size.x, size.y);
      
        if (this._field) this._initParticles();
        if (this._maskGeoJSON) this._updateMaskPath();
      },






      setMask: function(geojson) {
        this._maskGeoJSON = geojson;
        this._updateMaskPath();
      },
      
      _updateMaskPath: function() {
        if (!this._maskGeoJSON || !this._topLeft) return;
      
        const path = new Path2D();
      
        const addRing = (ring) => {
          ring.forEach(([lon, lat], i) => {
            const p = this._latLngToCanvasPoint(lat, lon);
            if (i === 0) path.moveTo(p.lat, p.lon);
            else path.lineTo(p.lat, p.lon);
          });
          path.closePath();
        };
      
        for (const feat of this._maskGeoJSON.features) {
          const geom = feat.geometry;
          if (!geom) continue;
      
          if (geom.type === "Polygon") {
            geom.coordinates.forEach(addRing);
          } else if (geom.type === "MultiPolygon") {
            geom.coordinates.forEach(poly => poly.forEach(addRing));
          }
        }
      
        this._maskPath = path;
      },

      
      _latLngToCanvasPoint: function (lat, lon) {
        const p = this._map.latLngToLayerPoint([lat, lon]);
        return p.subtract(this._topLeft);
      },
      
      _canvasPointToLatLng: function (x, y) {
        const p = L.point(x, y).add(this._topLeft);
        return this._map.layerPointToLatLng(p);
      },

      
      _initParticles: function() {
        const count = Math.round(this._map.getSize().x * 0.8);
        this._particles = Array.from({ length: count }, () => this._randomParticle());
      },
    
      _randomParticle: function() {
        const f = this._field;
        if (!f) return { lat: 54.5, lon: -114.0, age: 0 };
    
        const lonMin = f.lon0;
        const lonMax = f.lon0 + f.dx * (f.nx - 1);
        const latMax = f.lat0;
        const latMin = f.lat0 - f.dy * (f.ny - 1);
    
        for (let k = 0; k < 60; k++) {
          const lat = latMin + Math.random() * (latMax - latMin);
          const lon = lonMin + Math.random() * (lonMax - lonMin);
    
          const v = f.sample(lat, lon);
          if (!v) continue;
    
          const pt = this._latLngToCanvasPoint(lat, lon);
          if (pt.x >= 0 && pt.y >= 0 && pt.x <= this._canvas.width && pt.y <= this._canvas.height) {
            return { lat, lon, age: Math.random() * 200 };
          }
        }
    
        return { lat: 54.5, lon: -114.0, age: 0 };
      },
    
      _start: function() {
        if (this._anim) cancelAnimationFrame(this._anim);
        const frame = () => {
          this._step();
          this._anim = requestAnimationFrame(frame);
        };
        frame();
      },
    
      _step: function () {
        if (!this._field || !this._particles) return;
      
        const ctx = this._ctx;
      
        ctx.save();

        // Fade trails by removing alpha (not painting black)
        ctx.globalCompositeOperation = "destination-out";
        ctx.fillStyle = "rgba(0,0,0,0.05)";
        ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
        ctx.globalCompositeOperation = "source-over";
        
        // Apply Alberta mask
        // if (this._maskPath) ctx.clip(this._maskPath, "evenodd");

        ctx.lineWidth = 1.6;
        ctx.beginPath();
      
        for (const p of this._particles) {
          if (p.age++ > 150) {
            Object.assign(p, this._randomParticle());
            continue;
          }
      

          const ll = { lat: p.lat, lon: p.lon };
          const v = this._field.sample(ll.lat, ll.lon);
          if (!v) { Object.assign(p, this._randomParticle()); continue; }
          
          const TIME_SCALE = 3.5; 
          const dt = 1100 * TIME_SCALE;
          const metersPerDegLat = 111320;
          const metersPerDegLon = 111320 * Math.cos(ll.lat * Math.PI / 180);
          
          const lat2 = ll.lat + (v.v * dt) / metersPerDegLat;
          const lon2 = ll.lon + (v.u * dt) / metersPerDegLon;
          
          // Draw using projection only at render time
          const p1 = this._latLngToCanvasPoint(p.lat, p.lon);
          const p2 = this._latLngToCanvasPoint(lat2, lon2);

          const c = Math.min(255, Math.round(v.speed * 18));
          ctx.strokeStyle = `rgba(${Math.max(80, c)}, ${Math.max(40, 200-c)}, 255, 0.95)`;
          ctx.shadowColor = ctx.strokeStyle;
          ctx.shadowBlur = v.speed > 6 ? 6 : 2;


          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          
          // Update particle in geographic space
          p.lat = lat2;
          p.lon = lon2;
      
          if (!this._field.sample(p.lat, p.lon)) {
            Object.assign(p, this._randomParticle());
          }
        }
      
        ctx.stroke();
        ctx.restore();
      }
    });


    // ---------- Parse your JSONs into a sampler ----------
    function readHeader(json) {
      // Try common variants. Adjust once we see your actual header keys.
      const h = json.header || json[0]?.header || json;
      return {
        lo1: h.lo1 ?? h.lon0 ?? h.lo ?? h.lo1,
        la1: h.la1 ?? h.lat0 ?? h.la ?? h.la1,
        dx:  h.dx  ?? h.dlon ?? h.dx,
        dy:  h.dy  ?? h.dlat ?? h.dy,
        nx:  h.nx  ?? h.Nx   ?? h.nx,
        ny:  h.ny  ?? h.Ny   ?? h.ny,
      };
    }

    function buildField(uJson, vJson) {     
      const uh = uJson.header;
      const vh = vJson.header;

      const modelTime = uh.refTime || uh.referenceTime || uh.time || "Unknown time";

      
      // Your actual grid parameters
      const nx = uh.nx;          // 354
      const ny = uh.ny;          // 540
      const lon0 = uh.lo1;       // -121.76788
      const lat0 = uh.la1;       // 60.64398 (NORTHERN point)
      const dx = uh.dx;          // 0.04537
      const dy = uh.dy;          // 0.02274 POSITIVE = goes SOUTHWARD
           
      const uData = uJson.data;
      const vData = vJson.data;
      
      // Find first non-null value
      let firstNonNull = -1;
      for (let i = 0; i < uData.length; i++) {
        if (uData[i] !== null) {
          firstNonNull = i;
          break;
        }
      }
      
      
      return {
        nx, ny, lon0, lat0, dx, dy,modelTime,
        sample: (lat, lon) => {

          // Fractional grid position
          const fx = (lon - lon0) / dx;
          const fy = (lat0 - lat) / dy;
          
          const i0 = Math.floor(fx);
          const j0 = Math.floor(fy);
          const i1 = i0 + 1;
          const j1 = j0 + 1;
          
          if (i0 < 0 || i1 >= nx || j0 < 0 || j1 >= ny) return null;
          
          const tx = fx - i0;
          const ty = fy - j0;
          
          const idx00 = j0 * nx + i0;
          const idx10 = j0 * nx + i1;
          const idx01 = j1 * nx + i0;
          const idx11 = j1 * nx + i1;
          
          const u00 = uData[idx00], u10 = uData[idx10], u01 = uData[idx01], u11 = uData[idx11];
          const v00 = vData[idx00], v10 = vData[idx10], v01 = vData[idx01], v11 = vData[idx11];
          
          if ([u00,u10,u01,u11,v00,v10,v01,v11].some(v => v == null)) return null;
          
          // Bilinear interpolation
          const uu = (1-tx)*(1-ty)*u00 + tx*(1-ty)*u10 + (1-tx)*ty*u01 + tx*ty*u11;
          const vv = (1-tx)*(1-ty)*v00 + tx*(1-ty)*v10 + (1-tx)*ty*v01 + tx*ty*v11;

          // Handle null/missing data
          if (uu === null || vv === null || 
              uu === undefined || vv === undefined) {
            return null;
          }
          
          const speed = Math.sqrt(uu * uu + vv * vv);
          
          return {
            u: uu,
            v: vv,
            speed: speed
          };
        }
      };
    }

    async function loadWind() {
      const info = document.getElementById("info");
      info.textContent = "Loading wind JSONâ€¦";
    
      const uJsons = await Promise.all(U_URLS.map(u => fetch(u).then(r => r.json())));
      const vJsons = await Promise.all(V_URLS.map(v => fetch(v).then(r => r.json())));
    
      let activeField = buildField(uJsons[0], vJsons[0]);
      field = activeField;

      
      windTime.baseUTC = new Date(activeField.modelTime.endsWith("Z") 
        ? activeField.modelTime 
        : activeField.modelTime + "Z");

    
      // Quick sanity probe
      const test = activeField.sample(54.5, -114.0);
    
      // Animate forecast blending
      let t = 0;
      setInterval(() => {
        const i = Math.floor(t) % uJsons.length;
        const j = (i + 1) % uJsons.length;
        const a = t - Math.floor(t);
        
        windTime.i = i;
        windTime.a = a;
    
        const f1 = buildField(uJsons[i], vJsons[i]);
        const f2 = buildField(uJsons[j], vJsons[j]);
    
        activeField = {
          ...f1,
          sample: (lat, lon) => {
            const w1 = f1.sample(lat, lon);
            const w2 = f2.sample(lat, lon);
            if (!w1 || !w2) return null;
    
            const u = (1 - a) * w1.u + a * w2.u;
            const v = (1 - a) * w1.v + a * w2.v;
            return { u, v, speed: Math.sqrt(u * u + v * v) };
          }
        };
    
        windLayer.updateField(activeField);
        t += 0.02;
      }, 1000);
    
      info.textContent = "Wind loaded (particles running)";
      return field;
    }

    

    
    const windLayer = new WindLayer();
    windLayer.addTo(map);
    

    function runModel(){
    
      if (!selectedPoint){
        alert("Click on the map first.");
        return;
      }
    
      const time = document.getElementById("time").value;
      const hours = document.getElementById("hours").value;
    
      if (!time){
        alert("Enter a UTC time.");
        return;
      }
    
      document.getElementById("status").innerText = "Starting modelâ€¦";
    
      fetch("https://api.github.com/repos/DKevinM/AB_winds/actions/workflows/odour_index.yml/dispatches", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${window.GITHUB_TOKEN}`,
          "Accept": "application/vnd.github+json",
          "Content-Type": "application/json",
          "User-Agent": "Odour-Map"
        },
        body: JSON.stringify({
          ref: "main",
          inputs: {
            lat: selectedPoint.lat.toFixed(6),
            lon: selectedPoint.lng.toFixed(6),
            time_utc: time,
            hours_back: String(hours)
          }
        })
      })
      .then(res => {
        if (!res.ok) throw new Error("Dispatch failed");
        document.getElementById("status").innerText = "Model started â€” computingâ€¦";
      })
      .catch(err => {
        console.error(err);
        document.getElementById("status").innerText = "Error starting model";
      });
    }

    

    function getCompassArrow(deg) {
      const dirs = ["N","NE","E","SE","S","SW","W","NW"];
      return dirs[Math.round(deg / 45) % 8];
    }
    
    map.on("click", (e) => {
      if (!field) return;
    
      const { lat, lng } = e.latlng;
      const wind = field.sample(lat, lng);
    
      if (!wind) {
        L.popup()
          .setLatLng(e.latlng)
          .setContent("No wind data at this location")
          .openOn(map);
        return;
      }
    
      const dir = (270 - Math.atan2(wind.v, wind.u) * 180 / Math.PI + 360) % 360;
      const speed = wind.speed;
      const arrow = getCompassArrow(dir);
    
      const ageText = getDataAgeText(field.modelTime);

    
      const html = `
        <b>Wind at clicked point</b><br>
        Speed: ${speed.toFixed(2)} m/s<br>
        Direction: ${dir.toFixed(0)}Â° ${arrow}
      `;
    
      L.popup()
        .setLatLng(e.latlng)
        .setContent(html)
        .openOn(map);
    });


    

    loadWind()
      .then(f => {
        windLayer.setField(f);
    
        // Immediately show correct diagnostics
        document.getElementById("info").innerHTML = getWindTimeDiagnostics();
    
        // Update diagnostics every minute
        setInterval(() => {
          document.getElementById("info").innerHTML = getWindTimeDiagnostics();
        }, 60000);
      })
      .catch(err => {
        document.getElementById("info").textContent = "ERROR: " + err.message;
        console.error(err);
      });


    
    // Reload wind data every hour on the hour
    function scheduleHourlyReload() {
      const now = new Date(Date.now());
      const nextHour = new Date(now);
      nextHour.setHours(now.getHours() + 1, 0, 5, 0); // 5 sec after hour
    
      const delay = nextHour - now;
    
      setTimeout(() => {
        console.log("ðŸ”„ Hourly wind refresh");
        loadWind().then(f => windLayer.setField(f));
        scheduleHourlyReload();
      }, delay);
    }
    
    scheduleHourlyReload();
        
  </script>
</body>
</html>
