<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AB Wind (Leaflet)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }
    .info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 999;
      background: rgba(0,0,0,0.7);
      color: #fff;
      font: 14px/1.3 Arial, sans-serif;
      padding: 8px 10px;
      border-radius: 6px;
      max-width: 360px;
    }
    canvas.wind {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw !important;
      height: 100vh !important;
      z-index: 999999 !important;
      pointer-events: none;
      background: rgba(0, 0, 0, 0.15);
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="info" id="info">Loading wind…</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>



  <script>
    let field = null;
    // ---------- CONFIG YOU MAY NEED TO EDIT ----------
    // These MUST match whatever your ab_wind_json.py writes into the header.
    // If your JSON header names differ, adjust readHeader() below.
    const HOURS = [0,1,2,3];
    const U_URLS = HOURS.map(h => `data/AB_u_00${h}.json`);
    const V_URLS = HOURS.map(h => `data/AB_v_00${h}.json`);


    // If your grid is Alberta-only, set a reasonable start view:
    const map = L.map("map", { zoomControl: true }).setView([54.5, -114.0], 6);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 12,
      attribution: "&copy; OpenStreetMap"
    }).addTo(map);

    // ---------- Minimal wind particle canvas layer ----------
    const WindLayer = L.Layer.extend({
      onAdd: function(map) {
        this._map = map;
        this._canvas = L.DomUtil.create("canvas", "wind");
        this._canvas.classList.add("wind");
        this._ctx = this._canvas.getContext("2d");
        this._canvas.width = window.innerWidth;
        this._canvas.height = window.innerHeight;
        
        this._ctx.fillStyle = "rgba(255, 0, 0, 1)";
        this._ctx.fillRect(50, 50, 100, 100);
        
        console.log("CANVAS ADDED", this._canvas);
        
        map.getPanes().overlayPane.appendChild(this._canvas);
    
        map.on("move zoom resize", this._reset, this);
        this._reset();
      },

      _onZoomStart: function() {
        if (!this._ctx) return;
        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
      
        // Optional but recommended: reseed so you don't get "stuck" particles
        if (this._field) this._initParticles();
      },
    
      onRemove: function(map) {
        map.off("move zoom resize", this._reset, this);
        if (this._anim) cancelAnimationFrame(this._anim);
        this._canvas.remove();
      },
    
      setField: function(field) {
        this._field = field;
        this._initParticles();
        this._start();
      },
      
      updateField: function(field) {
        this._field = field;
      },
      
  
      _reset: function() {
        const size = this._map.getSize();
        this._canvas.width = size.x;
        this._canvas.height = size.y;
        this._ctx.clearRect(0, 0, size.x, size.y);
      
        if (this._field) this._initParticles();
      },



      setMask: function(geojson) {
        this._maskGeoJSON = geojson;
        this._updateMaskPath();
      },
      
      _updateMaskPath: function() {
        if (!this._maskGeoJSON || !this._topLeft) return;
      
        const path = new Path2D();
      
        const addRing = (ring) => {
          ring.forEach(([lon, lat], i) => {
            const p = this._latLngToCanvasPoint(lat, lon);
            if (i === 0) path.moveTo(p.x, p.y);
            else path.lineTo(p.x, p.y);
          });
          path.closePath();
        };
      
        for (const feat of this._maskGeoJSON.features) {
          const geom = feat.geometry;
          if (!geom) continue;
      
          if (geom.type === "Polygon") {
            geom.coordinates.forEach(addRing);
          } else if (geom.type === "MultiPolygon") {
            geom.coordinates.forEach(poly => poly.forEach(addRing));
          }
        }
      
        this._maskPath = path;
      },
      
      
      _initParticles: function() {
        const count = Math.round(this._map.getSize().x * 0.6);
        this._particles = Array.from({ length: count }, () => this._randomParticle());
      },
    
      _randomParticle: function() {
        const f = this._field;
        if (!f) return { x: this._canvas.width / 2, y: this._canvas.height / 2, age: 0 };
    
        const lonMin = f.lon0;
        const lonMax = f.lon0 + f.dx * (f.nx - 1);
        const latMax = f.lat0;
        const latMin = f.lat0 - f.dy * (f.ny - 1);
    
        for (let k = 0; k < 60; k++) {
          const lat = latMin + Math.random() * (latMax - latMin);
          const lon = lonMin + Math.random() * (lonMax - lonMin);
    
          const v = f.sample(lat, lon);
          if (!v) continue;
    
          const pt = this._map.latLngToContainerPoint([lat, lon]);
          if (pt.x >= 0 && pt.y >= 0 && pt.x <= this._canvas.width && pt.y <= this._canvas.height) {
            return { x: pt.x, y: pt.y, age: Math.random() * 200 };
          }
        }
    
        return { x: this._canvas.width / 2, y: this._canvas.height / 2, age: 0 };
      },
    
      _start: function() {
        if (this._anim) cancelAnimationFrame(this._anim);
        const frame = () => {
          this._step();
          this._anim = requestAnimationFrame(frame);
        };
        frame();
      },
    
      _step: function() {
        if (!this._field || !this._particles) return;
        const ctx = this._ctx;
                
        ctx.save();
        if (this._maskPath) ctx.clip(this._maskPath, "evenodd");

        // DEBUG: prove the canvas is drawing at all
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = "rgba(255,0,0,0.9)";
        ctx.fillRect(8, 8, 12, 12);
        
    
        // fade existing pixels by reducing alpha (keeps transparency)
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = "rgba(0, 0, 0, 0.05)";   // 0.03–0.08 is the sweet spot
        ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
        
        // draw new strokes normally
        ctx.globalCompositeOperation = "source-over";
        ctx.lineWidth = 0.9;
    
        for (const p of this._particles) {
          if (p.age++ > 200) {
            Object.assign(p, this._randomParticle());
            continue;
          }
    
          const ll = this._map.containerPointToLatLng([p.x, p.y]);
          const v = this._field.sample(ll.lat, ll.lng);
          if (!v) {
            Object.assign(p, this._randomParticle());
            continue;
          }
    
          const speed = v.speed;
          const step = Math.min(1.2, speed * 0.20);
    
          // Advect using a real time step (seconds)
          const dt = 600; // 10 minutes worth of wind per frame; tune 300–1200
          const metersPerDegLat = 111320;
          const metersPerDegLon = 111320 * Math.cos(ll.lat * Math.PI / 180);
          
          // target lat/lon after dt seconds
          const lat2 = ll.lat + (v.v * dt) / metersPerDegLat;
          const lon2 = ll.lng + (v.u * dt) / metersPerDegLon;
          
          const p1 = this._map.latLngToContainerPoint([ll.lat, ll.lng]);
          const p2 = this._map.latLngToContainerPoint([lat2, lon2]);
          
          // pixel motion this frame
          let dx = (p2.x - p1.x);
          let dy = (p2.y - p1.y);
          
          // clamp huge jumps (avoids streaks when zoomed in)
          const maxStepPx = 20;
          const mag = Math.hypot(dx, dy);
          if (mag > maxStepPx) {
            dx = (dx / mag) * maxStepPx;
            dy = (dy / mag) * maxStepPx;
          }
          
          const x2 = p.x + dx;
          const y2 = p.y + dy;

          
    
          const c = Math.min(255, Math.round(speed * 10));
          ctx.strokeStyle = `rgba(${c}, ${255 - c}, 255, 0.9)`;
    
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(x2, y2);
          ctx.stroke();
    
          p.x = x2;
          p.y = y2;
    
          if (p.x < 0 || p.y < 0 || p.x > this._canvas.width || p.y > this._canvas.height) {
            Object.assign(p, this._randomParticle());
          }
        }
        ctx.restore();
      }
    });


    // ---------- Parse your JSONs into a sampler ----------
    function readHeader(json) {
      // Try common variants. Adjust once we see your actual header keys.
      const h = json.header || json[0]?.header || json;
      return {
        lo1: h.lo1 ?? h.lon0 ?? h.lo ?? h.lo1,
        la1: h.la1 ?? h.lat0 ?? h.la ?? h.la1,
        dx:  h.dx  ?? h.dlon ?? h.dx,
        dy:  h.dy  ?? h.dlat ?? h.dy,
        nx:  h.nx  ?? h.Nx   ?? h.nx,
        ny:  h.ny  ?? h.Ny   ?? h.ny,
      };
    }

    function buildField(uJson, vJson) {
      console.log("DEBUG: First 50 U values:", uJson.data.slice(0, 50));
      console.log("DEBUG: First 50 V values:", vJson.data.slice(0, 50));
      
      const uh = uJson.header;
      const vh = vJson.header;
      
      // Your actual grid parameters
      const nx = uh.nx;          // 354
      const ny = uh.ny;          // 540
      const lon0 = uh.lo1;       // -121.76788
      const lat0 = uh.la1;       // 60.64398 (NORTHERN point)
      const dx = uh.dx;          // 0.04537
      const dy = uh.dy;          // 0.02274 POSITIVE = goes SOUTHWARD
      
      console.log(`Grid: ${nx}x${ny}, Origin: (${lon0}, ${lat0}), dx:${dx}, dy:${dy}`);
      console.log(`Grid covers: Lon ${lon0} to ${lon0 + dx * (nx-1)}, 
                   Lat ${lat0} to ${lat0 - dy * (ny-1)}`); // Note: minus because dy positive
      
      const uData = uJson.data;
      const vData = vJson.data;
      
      // Find first non-null value
      let firstNonNull = -1;
      for (let i = 0; i < uData.length; i++) {
        if (uData[i] !== null) {
          firstNonNull = i;
          break;
        }
      }
      console.log(`First non-null U at index ${firstNonNull}: ${uData[firstNonNull]}`);
      
      // Test different indices to understand data layout
      console.log("Testing data at various indices:");
      for (let idx of [1000, 5000, 10000, 50000, 100000]) {
        console.log(`  [${idx}]: U=${uData[idx]}, V=${vData[idx]}`);
      }
      
      return {
        nx, ny, lon0, lat0, dx, dy,
        sample: (lat, lon) => {

          // Fractional grid position
          const fx = (lon - lon0) / dx;
          const fy = (lat0 - lat) / dy;
          
          const i0 = Math.floor(fx);
          const j0 = Math.floor(fy);
          const i1 = i0 + 1;
          const j1 = j0 + 1;
          
          if (i0 < 0 || i1 >= nx || j0 < 0 || j1 >= ny) return null;
          
          const tx = fx - i0;
          const ty = fy - j0;
          
          const idx00 = j0 * nx + i0;
          const idx10 = j0 * nx + i1;
          const idx01 = j1 * nx + i0;
          const idx11 = j1 * nx + i1;
          
          const u00 = uData[idx00], u10 = uData[idx10], u01 = uData[idx01], u11 = uData[idx11];
          const v00 = vData[idx00], v10 = vData[idx10], v01 = vData[idx01], v11 = vData[idx11];
          
          if ([u00,u10,u01,u11,v00,v10,v01,v11].some(v => v == null)) return null;
          
          // Bilinear interpolation
          const uu = (1-tx)*(1-ty)*u00 + tx*(1-ty)*u10 + (1-tx)*ty*u01 + tx*ty*u11;
          const vv = (1-tx)*(1-ty)*v00 + tx*(1-ty)*v10 + (1-tx)*ty*v01 + tx*ty*v11;

          // Handle null/missing data
          if (uu === null || vv === null || 
              uu === undefined || vv === undefined) {
            return null;
          }
          
          const speed = Math.sqrt(uu * uu + vv * vv);
          
          return {
            u: uu,
            v: vv,
            speed: speed
          };
        }
      };
    }

    async function loadWind() {
      const info = document.getElementById("info");
      info.textContent = "Loading wind JSON…";
    
      const uJsons = await Promise.all(U_URLS.map(u => fetch(u).then(r => r.json())));
      const vJsons = await Promise.all(V_URLS.map(v => fetch(v).then(r => r.json())));
    
      let activeField = buildField(uJsons[0], vJsons[0]);
      field = activeField;
    
      // Quick sanity probe
      const test = activeField.sample(54.5, -114.0);
      console.log("TEST SAMPLE @ AB:", test);
    
      // Animate forecast blending
      let t = 0;
      setInterval(() => {
        const i = Math.floor(t) % uJsons.length;
        const j = (i + 1) % uJsons.length;
        const a = t - Math.floor(t);
    
        const f1 = buildField(uJsons[i], vJsons[i]);
        const f2 = buildField(uJsons[j], vJsons[j]);
    
        activeField = {
          ...f1,
          sample: (lat, lon) => {
            const w1 = f1.sample(lat, lon);
            const w2 = f2.sample(lat, lon);
            if (!w1 || !w2) return null;
    
            const u = (1 - a) * w1.u + a * w2.u;
            const v = (1 - a) * w1.v + a * w2.v;
            return { u, v, speed: Math.sqrt(u * u + v * v) };
          }
        };
    
        windLayer.updateField(activeField);
        t += 0.02;
      }, 1000);
    
      info.textContent = "Wind loaded (particles running)";
      return field;
    }


    const windLayer = new WindLayer();
    windLayer.addTo(map);

    fetch("data/Alberta.geojson")
      .then(r => r.json())
      .then(gj => windLayer.setMask(gj));
    

    loadWind()
      .then(field => windLayer.setField(field))
      .catch(err => {
        document.getElementById("info").textContent = "ERROR: " + err.message;
        console.error(err);
      });

    function runDiagnosticTest() {
      console.log("=== DIAGNOSTIC TEST ===");
      
      // Test 1: Check if files exist
      fetch(U_URLS[0]).then(r => {
        return r.json();
      }).then(data => {
        
        
        // Show first few data points
        const dataArray = data.data || data.values || data.u;
        if (dataArray && dataArray.length) {
        }
      }).catch(err => console.error("U fetch error:", err));
      
      // Repeat for V
      fetch(V_URLS[0]).then(r => {
        return r.json();
      }).then(data => {
        const dataArray = data.data || data.values || data.v;
        if (dataArray && dataArray.length) {
        }
      }).catch(err => console.error("V fetch error:", err));
    }
    
    // Run after page loads
    window.addEventListener('load', () => {
      setTimeout(runDiagnosticTest, 1000);
    });
        
  </script>
</body>
</html>
